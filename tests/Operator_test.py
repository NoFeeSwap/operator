# Copyright 2025, NoFeeSwap LLC - All rights reserved.
import pytest
import brownie
import sha3
from brownie import web3, accounts, Nofeeswap, NofeeswapDelegatee, ERC20FixedSupply, ERC1155FixedSupply, ERC6909FixedSupply, Operator, MockHook, MockPayer, Deployer, MockQuoter
from eth_abi import encode
from eth_abi.packed import encode_packed
from Nofee import logTest, PUSH0, PUSH10, PUSH16, PUSH32, NEG, ADD, SUB, MIN, MAX, MUL, DIV, DIV_ROUND_DOWN, DIV_ROUND_UP, LT, EQ, LTEQ, ISZERO, AND, OR, XOR, JUMPDEST, JUMP, REVERT, READ_TRANSIENT_BALANCE, READ_BALANCE_OF_NATIVE, READ_BALANCE_OF_ERC20, READ_BALANCE_OF_MULTITOKEN, READ_ALLOWANCE_ERC20, READ_ALLOWANCE_PERMIT2, READ_ALLOWANCE_ERC6909, READ_IS_OPERATOR_ERC6909, READ_IS_APPROVED_FOR_ALL_ERC1155, READ_DOUBLE_BALANCE, WRAP_NATIVE, UNWRAP_NATIVE, PERMIT_PERMIT2, PERMIT_BATCH_PERMIT2, TRANSFER_NATIVE, TRANSFER_FROM_PAYER_ERC20, TRANSFER_FROM_PAYER_PERMIT2, TRANSFER_FROM_PAYER_ERC6909, SAFE_TRANSFER_FROM_PAYER_ERC1155, CLEAR, TAKE_TOKEN, TAKE_ERC6909, TAKE_ERC1155, SYNC_TOKEN, SYNC_MULTITOKEN, SETTLE, MODIFY_SINGLE_BALANCE, MODIFY_DOUBLE_BALANCE, SWAP, MODIFY_POSITION, DONATE, QUOTE_SWAP, QUOTE_MODIFY_POSITION, QUOTE_DONATE, QUOTER_TRANSIENT_ACCESS, address0, keccak, keccakPacked, toInt, twosComplementInt8, twosComplement, encodeKernelCompact, encodeCurve, getPoolId

permit2Bytecode = '60c0346100bb574660a052602081017f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a86681527f9ac997416e8ff9d2ff6bebeb7149f65cdae5e32e2b90440b566bb3044041d36a60408301524660608301523060808301526080825260a082019180831060018060401b038411176100a557826040525190206080526123c090816100c1823960805181611b47015260a05181611b210152f35b634e487b7160e01b600052604160045260246000fd5b600080fdfe6040608081526004908136101561001557600080fd5b600090813560e01c80630d58b1db1461126c578063137c29fe146110755780632a2d80d114610db75780632b67b57014610bde57806330f28b7a14610ade5780633644e51514610a9d57806336c7851614610a285780633ff9dcb1146109a85780634fe02b441461093f57806365d9723c146107ac57806387517c451461067a578063927da105146105c3578063cc53287f146104a3578063edd9444b1461033a5763fe8ec1a7146100c657600080fd5b346103365760c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103365767ffffffffffffffff833581811161033257610114903690860161164b565b60243582811161032e5761012b903690870161161a565b6101336114e6565b9160843585811161032a5761014b9036908a016115c1565b98909560a43590811161032657610164913691016115c1565b969095815190610173826113ff565b606b82527f5065726d697442617463685769746e6573735472616e7366657246726f6d285460208301527f6f6b656e5065726d697373696f6e735b5d207065726d69747465642c61646472838301527f657373207370656e6465722c75696e74323536206e6f6e63652c75696e74323560608301527f3620646561646c696e652c000000000000000000000000000000000000000000608083015282519a8b9181610222602085018096611f93565b918237018a8152039961025b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe09b8c8101835282611437565b5190209085515161026b81611ebb565b908a5b8181106102f95750506102f6999a6102ed9183516102a081610294602082018095611f66565b03848101835282611437565b519020602089810151858b015195519182019687526040820192909252336060820152608081019190915260a081019390935260643560c08401528260e081015b03908101835282611437565b51902093611cf7565b80f35b8061031161030b610321938c5161175e565b51612054565b61031b828661175e565b52611f0a565b61026e565b8880fd5b8780fd5b8480fd5b8380fd5b5080fd5b5091346103365760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103365767ffffffffffffffff9080358281116103325761038b903690830161164b565b60243583811161032e576103a2903690840161161a565b9390926103ad6114e6565b9160643590811161049f576103c4913691016115c1565b949093835151976103d489611ebb565b98885b81811061047d5750506102f697988151610425816103f9602082018095611f66565b037fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08101835282611437565b5190206020860151828701519083519260208401947ffcf35f5ac6a2c28868dc44c302166470266239195f02b0ee408334829333b7668652840152336060840152608083015260a082015260a081526102ed8161141b565b808b61031b8261049461030b61049a968d5161175e565b9261175e565b6103d7565b8680fd5b5082346105bf57602090817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126103325780359067ffffffffffffffff821161032e576104f49136910161161a565b929091845b848110610504578580f35b8061051a610515600193888861196c565b61197c565b61052f84610529848a8a61196c565b0161197c565b3389528385528589209173ffffffffffffffffffffffffffffffffffffffff80911692838b528652868a20911690818a5285528589207fffffffffffffffffffffffff000000000000000000000000000000000000000081541690558551918252848201527f89b1add15eff56b3dfe299ad94e01f2b52fbcb80ae1a3baea6ae8c04cb2b98a4853392a2016104f9565b8280fd5b50346103365760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657610676816105ff6114a0565b936106086114c3565b6106106114e6565b73ffffffffffffffffffffffffffffffffffffffff968716835260016020908152848420928816845291825283832090871683528152919020549251938316845260a083901c65ffffffffffff169084015260d09190911c604083015281906060820190565b0390f35b50346103365760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610336576106b26114a0565b906106bb6114c3565b916106c46114e6565b65ffffffffffff926064358481169081810361032a5779ffffffffffff0000000000000000000000000000000000000000947fda9fa7c1b00402c17d0161b249b1ab8bbec047c5a52207b9c112deffd817036b94338a5260016020527fffffffffffff0000000000000000000000000000000000000000000000000000858b209873ffffffffffffffffffffffffffffffffffffffff809416998a8d5260205283878d209b169a8b8d52602052868c209486156000146107a457504216925b8454921697889360a01b16911617179055815193845260208401523392a480f35b905092610783565b5082346105bf5760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf576107e56114a0565b906107ee6114c3565b9265ffffffffffff604435818116939084810361032a57338852602091600183528489209673ffffffffffffffffffffffffffffffffffffffff80911697888b528452858a20981697888a5283528489205460d01c93848711156109175761ffff9085840316116108f05750907f55eb90d810e1700b35a8e7e25395ff7f2b2259abd7415ca2284dfb1c246418f393929133895260018252838920878a528252838920888a5282528389209079ffffffffffffffffffffffffffffffffffffffffffffffffffff7fffffffffffff000000000000000000000000000000000000000000000000000083549260d01b16911617905582519485528401523392a480f35b84517f24d35a26000000000000000000000000000000000000000000000000000000008152fd5b5084517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b503461033657807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610336578060209273ffffffffffffffffffffffffffffffffffffffff61098f6114a0565b1681528084528181206024358252845220549051908152f35b5082346105bf57817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf577f3704902f963766a4e561bbaab6e6cdc1b1dd12f6e9e99648da8843b3f46b918d90359160243533855284602052818520848652602052818520818154179055815193845260208401523392a280f35b8234610a9a5760807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc360112610a9a57610a606114a0565b610a686114c3565b610a706114e6565b6064359173ffffffffffffffffffffffffffffffffffffffff8316830361032e576102f6936117a1565b80fd5b503461033657817ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657602090610ad7611b1e565b9051908152f35b508290346105bf576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf57610b1a3661152a565b90807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7c36011261033257610b4c611478565b9160e43567ffffffffffffffff8111610bda576102f694610b6f913691016115c1565b939092610b7c8351612054565b6020840151828501519083519260208401947f939c21a48a8dbe3a9a2404a1d46691e4d39f6583d6ec6b35714604c986d801068652840152336060840152608083015260a082015260a08152610bd18161141b565b51902091611c25565b8580fd5b509134610336576101007ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033657610c186114a0565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc360160c08112610332576080855191610c51836113e3565b1261033257845190610c6282611398565b73ffffffffffffffffffffffffffffffffffffffff91602435838116810361049f578152604435838116810361049f57602082015265ffffffffffff606435818116810361032a5788830152608435908116810361049f576060820152815260a435938285168503610bda576020820194855260c4359087830182815260e43567ffffffffffffffff811161032657610cfe90369084016115c1565b929093804211610d88575050918591610d786102f6999a610d7e95610d238851611fbe565b90898c511690519083519260208401947ff3841cd1ff0085026a6327b620b67997ce40f282c88a8e905a7a5626e310f3d086528401526060830152608082015260808152610d70816113ff565b519020611bd9565b916120c7565b519251169161199d565b602492508a51917fcd21db4f000000000000000000000000000000000000000000000000000000008352820152fd5b5091346103365760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc93818536011261033257610df36114a0565b9260249081359267ffffffffffffffff9788851161032a578590853603011261049f578051978589018981108282111761104a578252848301358181116103265785019036602383011215610326578382013591610e50836115ef565b90610e5d85519283611437565b838252602093878584019160071b83010191368311611046578801905b828210610fe9575050508a526044610e93868801611509565b96838c01978852013594838b0191868352604435908111610fe557610ebb90369087016115c1565b959096804211610fba575050508998995151610ed681611ebb565b908b5b818110610f9757505092889492610d7892610f6497958351610f02816103f98682018095611f66565b5190209073ffffffffffffffffffffffffffffffffffffffff9a8b8b51169151928551948501957faf1b0d30d2cab0380e68f0689007e3254993c596f2fdd0aaa7f4d04f794408638752850152830152608082015260808152610d70816113ff565b51169082515192845b848110610f78578580f35b80610f918585610f8b600195875161175e565b5161199d565b01610f6d565b80610311610fac8e9f9e93610fb2945161175e565b51611fbe565b9b9a9b610ed9565b8551917fcd21db4f000000000000000000000000000000000000000000000000000000008352820152fd5b8a80fd5b6080823603126110465785608091885161100281611398565b61100b85611509565b8152611018838601611509565b838201526110278a8601611607565b8a8201528d611037818701611607565b90820152815201910190610e7a565b8c80fd5b84896041867f4e487b7100000000000000000000000000000000000000000000000000000000835252fd5b5082346105bf576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126105bf576110b03661152a565b91807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7c360112610332576110e2611478565b67ffffffffffffffff93906101043585811161049f5761110590369086016115c1565b90936101243596871161032a57611125610bd1966102f6983691016115c1565b969095825190611134826113ff565b606482527f5065726d69745769746e6573735472616e7366657246726f6d28546f6b656e5060208301527f65726d697373696f6e73207065726d69747465642c6164647265737320737065848301527f6e6465722c75696e74323536206e6f6e63652c75696e7432353620646561646c60608301527f696e652c0000000000000000000000000000000000000000000000000000000060808301528351948591816111e3602085018096611f93565b918237018b8152039361121c7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe095868101835282611437565b5190209261122a8651612054565b6020878101518589015195519182019687526040820192909252336060820152608081019190915260a081019390935260e43560c08401528260e081016102e1565b5082346105bf576020807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc36011261033257813567ffffffffffffffff92838211610bda5736602383011215610bda5781013592831161032e576024906007368386831b8401011161049f57865b8581106112e5578780f35b80821b83019060807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc83360301126103265761139288876001946060835161132c81611398565b611368608461133c8d8601611509565b9485845261134c60448201611509565b809785015261135d60648201611509565b809885015201611509565b918291015273ffffffffffffffffffffffffffffffffffffffff80808093169516931691166117a1565b016112da565b6080810190811067ffffffffffffffff8211176113b457604052565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6060810190811067ffffffffffffffff8211176113b457604052565b60a0810190811067ffffffffffffffff8211176113b457604052565b60c0810190811067ffffffffffffffff8211176113b457604052565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff8211176113b457604052565b60c4359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b600080fd5b6004359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b6024359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b6044359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b359073ffffffffffffffffffffffffffffffffffffffff8216820361149b57565b7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc01906080821261149b576040805190611563826113e3565b8082941261149b57805181810181811067ffffffffffffffff8211176113b457825260043573ffffffffffffffffffffffffffffffffffffffff8116810361149b578152602435602082015282526044356020830152606435910152565b9181601f8401121561149b5782359167ffffffffffffffff831161149b576020838186019501011161149b57565b67ffffffffffffffff81116113b45760051b60200190565b359065ffffffffffff8216820361149b57565b9181601f8401121561149b5782359167ffffffffffffffff831161149b576020808501948460061b01011161149b57565b91909160608184031261149b576040805191611666836113e3565b8294813567ffffffffffffffff9081811161149b57830182601f8201121561149b578035611693816115ef565b926116a087519485611437565b818452602094858086019360061b8501019381851161149b579086899897969594939201925b8484106116e3575050505050855280820135908501520135910152565b90919293949596978483031261149b578851908982019082821085831117611730578a928992845261171487611509565b81528287013583820152815201930191908897969594936116c6565b602460007f4e487b710000000000000000000000000000000000000000000000000000000081526041600452fd5b80518210156117725760209160051b010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b92919273ffffffffffffffffffffffffffffffffffffffff604060008284168152600160205282828220961695868252602052818120338252602052209485549565ffffffffffff8760a01c16804211611884575082871696838803611812575b5050611810955016926118b5565b565b878484161160001461184f57602488604051907ff96fb0710000000000000000000000000000000000000000000000000000000082526004820152fd5b7fffffffffffffffffffffffff000000000000000000000000000000000000000084846118109a031691161790553880611802565b602490604051907fd81b2f2e0000000000000000000000000000000000000000000000000000000082526004820152fd5b9060006064926020958295604051947f23b872dd0000000000000000000000000000000000000000000000000000000086526004860152602485015260448401525af13d15601f3d116001600051141617161561190e57565b60646040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f5452414e534645525f46524f4d5f4641494c45440000000000000000000000006044820152fd5b91908110156117725760061b0190565b3573ffffffffffffffffffffffffffffffffffffffff8116810361149b5790565b9065ffffffffffff908160608401511673ffffffffffffffffffffffffffffffffffffffff908185511694826020820151169280866040809401511695169560009187835260016020528383208984526020528383209916988983526020528282209184835460d01c03611af5579185611ace94927fc6a377bfc4eb120024a8ac08eef205be16b817020812c73223e81d1bdb9708ec98979694508715600014611ad35779ffffffffffff00000000000000000000000000000000000000009042165b60a01b167fffffffffffff00000000000000000000000000000000000000000000000000006001860160d01b1617179055519384938491604091949373ffffffffffffffffffffffffffffffffffffffff606085019616845265ffffffffffff809216602085015216910152565b0390a4565b5079ffffffffffff000000000000000000000000000000000000000087611a60565b600484517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b467f000000000000000000000000000000000000000000000000000000000000000003611b69577f000000000000000000000000000000000000000000000000000000000000000090565b60405160208101907f8cad95687ba82c2ce50e74f7b754645e5117c3a5bec8151c0726d5857980a86682527f9ac997416e8ff9d2ff6bebeb7149f65cdae5e32e2b90440b566bb3044041d36a604082015246606082015230608082015260808152611bd3816113ff565b51902090565b611be1611b1e565b906040519060208201927f190100000000000000000000000000000000000000000000000000000000000084526022830152604282015260428152611bd381611398565b9192909360a435936040840151804211611cc65750602084510151808611611c955750918591610d78611c6594611c60602088015186611e47565b611bd9565b73ffffffffffffffffffffffffffffffffffffffff809151511692608435918216820361149b57611810936118b5565b602490604051907f3728b83d0000000000000000000000000000000000000000000000000000000082526004820152fd5b602490604051907fcd21db4f0000000000000000000000000000000000000000000000000000000082526004820152fd5b959093958051519560409283830151804211611e175750848803611dee57611d2e918691610d7860209b611c608d88015186611e47565b60005b868110611d42575050505050505050565b611d4d81835161175e565b5188611d5a83878a61196c565b01359089810151808311611dbe575091818888886001968596611d84575b50505050505001611d31565b611db395611dad9273ffffffffffffffffffffffffffffffffffffffff6105159351169561196c565b916118b5565b803888888883611d78565b6024908651907f3728b83d0000000000000000000000000000000000000000000000000000000082526004820152fd5b600484517fff633a38000000000000000000000000000000000000000000000000000000008152fd5b6024908551907fcd21db4f0000000000000000000000000000000000000000000000000000000082526004820152fd5b9073ffffffffffffffffffffffffffffffffffffffff600160ff83161b9216600052600060205260406000209060081c6000526020526040600020818154188091551615611e9157565b60046040517f756688fe000000000000000000000000000000000000000000000000000000008152fd5b90611ec5826115ef565b611ed26040519182611437565b8281527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0611f0082946115ef565b0190602036910137565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8114611f375760010190565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b805160208092019160005b828110611f7f575050505090565b835185529381019392810192600101611f71565b9081519160005b838110611fab575050016000815290565b8060208092840101518185015201611f9a565b60405160208101917f65626cad6cb96493bf6f5ebea28756c966f023ab9e8a83a7101849d5573b3678835273ffffffffffffffffffffffffffffffffffffffff8082511660408401526020820151166060830152606065ffffffffffff9182604082015116608085015201511660a082015260a0815260c0810181811067ffffffffffffffff8211176113b45760405251902090565b6040516020808201927f618358ac3db8dc274f0cd8829da7e234bd48cd73c4a740aede1adec9846d06a1845273ffffffffffffffffffffffffffffffffffffffff81511660408401520151606082015260608152611bd381611398565b919082604091031261149b576020823592013590565b6000843b61222e5750604182036121ac576120e4828201826120b1565b939092604010156117725760209360009360ff6040608095013560f81c5b60405194855216868401526040830152606082015282805260015afa156121a05773ffffffffffffffffffffffffffffffffffffffff806000511691821561217657160361214c57565b60046040517f815e1d64000000000000000000000000000000000000000000000000000000008152fd5b60046040517f8baa579f000000000000000000000000000000000000000000000000000000008152fd5b6040513d6000823e3d90fd5b60408203612204576121c0918101906120b1565b91601b7f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff84169360ff1c019060ff8211611f375760209360009360ff608094612102565b60046040517f4be6321b000000000000000000000000000000000000000000000000000000008152fd5b929391601f928173ffffffffffffffffffffffffffffffffffffffff60646020957fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0604051988997889687947f1626ba7e000000000000000000000000000000000000000000000000000000009e8f8752600487015260406024870152816044870152868601378b85828601015201168101030192165afa9081156123a857829161232a575b507fffffffff000000000000000000000000000000000000000000000000000000009150160361230057565b60046040517fb0669cbc000000000000000000000000000000000000000000000000000000008152fd5b90506020813d82116123a0575b8161234460209383611437565b810103126103365751907fffffffff0000000000000000000000000000000000000000000000000000000082168203610a9a57507fffffffff0000000000000000000000000000000000000000000000000000000090386122d4565b3d9150612337565b6040513d84823e3d90fdfea164736f6c6343000811000a'
weth9Bytecode = '60606040526040805190810160405280600d81526020017f57726170706564204574686572000000000000000000000000000000000000008152506000908051906020019061004f9291906100c8565b506040805190810160405280600481526020017f57455448000000000000000000000000000000000000000000000000000000008152506001908051906020019061009b9291906100c8565b506012600260006101000a81548160ff021916908360ff16021790555034156100c357600080fd5b61016d565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061010957805160ff1916838001178555610137565b82800160010185558215610137579182015b8281111561013657825182559160200191906001019061011b565b5b5090506101449190610148565b5090565b61016a91905b8082111561016657600081600090555060010161014e565b5090565b90565b610c348061017c6000396000f3006060604052600436106100af576000357c0100000000000000000000000000000000000000000000000000000000900463ffffffff16806306fdde03146100b9578063095ea7b31461014757806318160ddd146101a157806323b872dd146101ca5780632e1a7d4d14610243578063313ce5671461026657806370a082311461029557806395d89b41146102e2578063a9059cbb14610370578063d0e30db0146103ca578063dd62ed3e146103d4575b6100b7610440565b005b34156100c457600080fd5b6100cc6104dd565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561010c5780820151818401526020810190506100f1565b50505050905090810190601f1680156101395780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561015257600080fd5b610187600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061057b565b604051808215151515815260200191505060405180910390f35b34156101ac57600080fd5b6101b461066d565b6040518082815260200191505060405180910390f35b34156101d557600080fd5b610229600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803590602001909190505061068c565b604051808215151515815260200191505060405180910390f35b341561024e57600080fd5b61026460048080359060200190919050506109d9565b005b341561027157600080fd5b610279610b05565b604051808260ff1660ff16815260200191505060405180910390f35b34156102a057600080fd5b6102cc600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610b18565b6040518082815260200191505060405180910390f35b34156102ed57600080fd5b6102f5610b30565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561033557808201518184015260208101905061031a565b50505050905090810190601f1680156103625780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b341561037b57600080fd5b6103b0600480803573ffffffffffffffffffffffffffffffffffffffff16906020019091908035906020019091905050610bce565b604051808215151515815260200191505060405180910390f35b6103d2610440565b005b34156103df57600080fd5b61042a600480803573ffffffffffffffffffffffffffffffffffffffff1690602001909190803573ffffffffffffffffffffffffffffffffffffffff16906020019091905050610be3565b6040518082815260200191505060405180910390f35b34600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055503373ffffffffffffffffffffffffffffffffffffffff167fe1fffcc4923d04b559f4d29a8bfc6cda04eb5b0d3c460751c2402c5c5cc9109c346040518082815260200191505060405180910390a2565b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156105735780601f1061054857610100808354040283529160200191610573565b820191906000526020600020905b81548152906001019060200180831161055657829003601f168201915b505050505081565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60003073ffffffffffffffffffffffffffffffffffffffff1631905090565b600081600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101515156106dc57600080fd5b3373ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff16141580156107b457507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414155b156108cf5781600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015151561084457600080fd5b81600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055505b81600360008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410151515610a2757600080fd5b80600360003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff166108fc829081150290604051600060405180830381858888f193505050501515610ab457600080fd5b3373ffffffffffffffffffffffffffffffffffffffff167f7fcf532c15f0a6db0bd6d0e038bea71d30d808c7d98cb3bf7268a95bf5081b65826040518082815260200191505060405180910390a250565b600260009054906101000a900460ff1681565b60036020528060005260406000206000915090505481565b60018054600181600116156101000203166002900480601f016020809104026020016040519081016040528092919081815260200182805460018160011615610100020316600290048015610bc65780601f10610b9b57610100808354040283529160200191610bc6565b820191906000526020600020905b815481529060010190602001808311610ba957829003601f168201915b505050505081565b6000610bdb33848461068c565b905092915050565b60046020528160005260406000206020528060005260406000206000915091505054815600a165627a7a72305820deb4c2ccab3c2fdca32ab3f46728389c2fe2c165d5fafa07661e4e004f6c344a0029'

@pytest.fixture(scope="module", autouse=True)
def deployment(module_isolation):
    root = accounts[0]
    owner = accounts.add()
    deployer = Deployer.deploy(root, {'from': root})
    permit2 = deployer.addressOf(1)
    weth9 = deployer.addressOf(2)
    delegatee = deployer.addressOf(3)
    nofeeswap = deployer.addressOf(4)
    deployer.create3(
        1,
        permit2Bytecode, 
        {'from': root}
    )
    deployer.create3(
        2,
        weth9Bytecode,
        {'from': root}
    )
    deployer.create3(
        3,
        NofeeswapDelegatee.bytecode + encode(
            ['address'],
            [nofeeswap]
        ).hex(), 
        {'from': root}
    )
    deployer.create3(
        4,
        Nofeeswap.bytecode + encode(
            ['address', 'address'],
            [delegatee, root.address]
        ).hex(), 
        {'from': root}
    )
    delegatee = NofeeswapDelegatee.at(delegatee)
    nofeeswap = Nofeeswap.at(nofeeswap)
    hook = MockHook.deploy({'from': root})
    payer = MockPayer.deploy({'from': root})
    quoter = MockQuoter.deploy({'from': root})
    operator = Operator.deploy(nofeeswap, permit2, weth9, quoter, {'from': root})

    root.transfer(to = payer, amount = root.balance() // 2)
    token0 = ERC20FixedSupply.deploy("ERC20_0", "ERC20_0", 2**120, payer, {'from': root})
    token1 = ERC20FixedSupply.deploy("ERC20_1", "ERC20_1", 2**120, payer, {'from': root})
    if toInt(token0.address) > toInt(token1.address):
        token0, token1 = token1, token0
    tokenERC1155 = ERC1155FixedSupply.deploy("ERC1155", 2**120, 1, payer, {'from': root})
    tokenERC6909 = ERC6909FixedSupply.deploy(2**120, 1, payer, {'from': root})

    payer.call(token0, 0, address0, [], token0.approve.encode_input(operator, 2**256 - 1))
    payer.call(token1, 0, address0, [], token1.approve.encode_input(operator, 2**256 - 1))
    payer.call(tokenERC6909, 0, address0, [], tokenERC6909.approve.encode_input(operator, 1, 2**256 - 1))
    payer.call(tokenERC6909, 0, address0, [], tokenERC6909.setOperator.encode_input(operator, True))
    payer.call(tokenERC1155, 0, address0, [], tokenERC1155.setApprovalForAll.encode_input(operator, True))
    payer.call(nofeeswap, 0, address0, [], nofeeswap.setOperator.encode_input(operator, True))

    payer.call(token0, 0, address0, [], token0.approve.encode_input(permit2, 2**256 - 1))
    payer.call(token1, 0, address0, [], token1.approve.encode_input(permit2, 2**256 - 1))

    selector = keccakPacked(['string'],['deposit()']) >> 224
    input = encode(['uint32'], [selector])[28:]
    payer.call(weth9, payer.balance() // 2, address0, [], input)

    selector = keccakPacked(['string'],['approve(address,address,uint160,uint48)']) >> 224
    token = token0.address
    spender = operator.address
    amount = 2 ** 160 - 1
    deadline = 2 ** 48 - 1
    input = encode(['uint32', 'address', 'address', 'uint256', 'uint48'], [selector, token, spender, amount, deadline])[28:]
    payer.call(permit2, 0, address0, [], input)

    selector = keccakPacked(['string'],['approve(address,address,uint160,uint48)']) >> 224
    token = token1.address
    spender = operator.address
    amount = 2 ** 160 - 1
    deadline = 2 ** 48 - 1
    input = encode(['uint32', 'address', 'address', 'uint256', 'uint48'], [selector, token, spender, amount, deadline])[28:]
    payer.call(permit2, 0, address0, [], input)

    token0.approve(owner, 2 ** 15, {'from': root})
    token1.approve(owner, 2 ** 15, {'from': root})

    tokenERC1155.setApprovalForAll(owner, True, {'from': root})
    tokenERC1155.setApprovalForAll(root, False, {'from': owner})

    tokenERC6909.approve(owner, 2, 2 ** 25, {'from': root})

    tokenERC6909.setOperator(owner, True, {'from': root})
    tokenERC6909.setOperator(root, False, {'from': owner})

    selector = keccakPacked(['string'],['approve(address,address,uint160,uint48)']) >> 224
    token = token0.address
    spender = owner.address
    amount = 2 ** 120 - 1
    deadline = 2 ** 48 - 1
    input = encode(['uint32', 'address', 'address', 'uint256', 'uint48'], [selector, token, spender, amount, deadline])[28:]
    root.transfer(to=permit2, data=input)

    selector = keccakPacked(['string'],['approve(address,address,uint160,uint48)']) >> 224
    token = token1.address
    spender = owner.address
    amount = 2 ** 120 - 1
    deadline = 2 ** 48 - 1
    input = encode(['uint32', 'address', 'address', 'uint256', 'uint48'], [selector, token, spender, amount, deadline])[28:]
    root.transfer(to=permit2, data=input)

    deadline = 2 ** 32 - 1

    return root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline

def test_PUSH0(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    slot = 10

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'uint256'],
      [PUSH32, (1 << 256) - 1]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint8'],
      [PUSH0, slot]
    )
    transientSlots = [slot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(slot) == 0

@pytest.mark.parametrize('value', [-(1 << 79), -10, 0, 10, (1 << 79) - 1])
def test_PUSH10(deployment, value, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    slot = 10

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'int80', 'uint8'],
      [PUSH10, value, slot]
    )
    transientSlots = [slot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(slot) == twosComplement(value)

@pytest.mark.parametrize('value', [-(1 << 127), -10, 0, 10, (1 << 127) - 1])
def test_PUSH16(deployment, value, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    slot = 10

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'int128', 'uint8'],
      [PUSH16, value, slot]
    )
    transientSlots = [slot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(slot) == twosComplement(value)

@pytest.mark.parametrize('value', [-(1 << 255), -10, 0, 10, (1 << 255) - 1])
def test_PUSH32(deployment, value, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    slot = 10

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, value, slot]
    )
    transientSlots = [slot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(slot) == twosComplement(value)

@pytest.mark.parametrize('value', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_NEG(deployment, value, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    slot = 10

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, value, slot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint8', 'uint8'],
      [NEG, slot, slot]
    )
    transientSlots = [slot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(slot) == twosComplement(- value)

def test_NEG_overflow(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    slot = 10
    value = - (1 << 255)

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, value, slot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint8', 'uint8'],
      [NEG, slot, slot]
    )
    transientSlots = [slot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_ADD(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = iValue + jValue

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [ADD, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == twosComplement(kValue)

def test_ADD_overflow(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    iValue = 101
    jValue = 2 ** 255 - 1

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [ADD, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    iValue = -101
    jValue = 1 - (2 ** 255)

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [ADD, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_SUB(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = iValue - jValue

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SUB, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == twosComplement(kValue)

def test_SUB_overflow(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    iValue = 101
    jValue = 1 - 2 ** 255

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SUB, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    iValue = -101
    jValue = 2 ** 255 - 1

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SUB, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_MIN(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = min(iValue, jValue)

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [MIN, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == twosComplement(kValue)

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_MAX(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = max(iValue, jValue)

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [MAX, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == twosComplement(kValue)

@pytest.mark.parametrize('iValue', [- (1 << 100), -10, 0, 10, 1 << 100])
@pytest.mark.parametrize('jValue', [- (1 << 100), -10, 0, 10, 1 << 100])
def test_MUL(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = iValue * jValue

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [MUL, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == twosComplement(kValue)

def test_MUL_overflow(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    iValue = 2 ** 128
    jValue = 1 + 2 ** 128

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [MUL, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    iSlot = 10
    jSlot = 20
    kSlot = 35

    iValue = - 2 ** 128
    jValue = 1 + 2 ** 128

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [MUL, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    iSlot = 10
    jSlot = 20
    kSlot = 35

    iValue = - 2 ** 128
    jValue = 1 - 2 ** 128

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [MUL, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    iSlot = 10
    jSlot = 20
    kSlot = 35

    iValue = - 2 ** 200
    jValue = - 2 ** 80

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [MUL, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 20), -10, 10, 1 << 20])
def test_DIV(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = iValue // jValue if (iValue * jValue >= 0) else (- ((- iValue) // jValue))

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == twosComplement(kValue)

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 20), -4, 4, 1 << 20])
def test_DIV_ROUND_DOWN(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = iValue // jValue

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV_ROUND_DOWN, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == twosComplement(kValue)

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 20), -4, 4, 1 << 20])
def test_DIV_ROUND_UP(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = - ((- iValue) // jValue)

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV_ROUND_UP, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == twosComplement(kValue)

def test_DIV_overflow(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    iValue = 2 ** 128
    jValue = 0

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV_ROUND_DOWN, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV_ROUND_UP, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    iValue = -(1 << 255)
    jValue = -1

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV_ROUND_DOWN, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [DIV_ROUND_UP, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_LT(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = 1 if (iValue < jValue) else 0

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [LT, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == kValue

    iValue = 250
    jValue = 101
    kValue = 0

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [LT, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == kValue

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_EQ(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = 1 if (iValue == jValue) else 0

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [EQ, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == kValue

    iValue = 101
    jValue = 101
    kValue = 1

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [EQ, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == kValue

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_LTEQ(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = 1 if (iValue <= jValue) else 0

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [LTEQ, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == kValue

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_ISZERO(deployment, iValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20

    jValue = 1 if (iValue == 0) else 0

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint8', 'uint8'],
      [ISZERO, iSlot, jSlot]
    )
    transientSlots = [iSlot, jSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(jSlot) == jValue

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_AND(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = twosComplement(iValue) & twosComplement(jValue)

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [AND, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == kValue

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_OR(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = twosComplement(iValue) | twosComplement(jValue)

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [OR, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == kValue

@pytest.mark.parametrize('iValue', [- (1 << 200), -10, 0, 10, 1 << 200])
@pytest.mark.parametrize('jValue', [- (1 << 200), -10, 0, 10, 1 << 200])
def test_XOR(deployment, iValue, jValue, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 10
    jSlot = 20
    kSlot = 35

    kValue = twosComplement(iValue) ^ twosComplement(jValue)

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [XOR, iSlot, jSlot, kSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(kSlot) == kValue

def test_IF(deployment, request, worker_id):
    logTest(request, worker_id)

    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    iSlot = 1
    jSlot = 2
    kSlot = 3

    iValue = 0
    jValue = 250
    kValue = 301

    sequence = [0] * 5
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint16', 'uint8'],
      [0, 0, 0]
    )
    sequence[2] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, jValue, jSlot]
    )
    sequence[3] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, kValue, kSlot]
    )
    sequence[4] = encode_packed(
      ['uint8'],
      [JUMPDEST]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint16', 'uint8'],
      [JUMP, sum([len(action) for action in sequence[0:4]]), iSlot]
    )
    transientSlots = [iSlot, jSlot, kSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(jSlot) == jValue
    assert payer.storageAccess(kSlot) == kValue

    iValue = 1
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )

    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(jSlot) == 0
    assert payer.storageAccess(kSlot) == 0

    sequence[4] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, iValue, iSlot]
    )

    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

def test_REVERT(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8'],
      [REVERT]
    )
    transientSlots = []
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

def test_READ_TRANSIENT_BALANCE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 95
    successSlot0 = 195
    resultSlot0 = 200
    resultSlot1 = 208
    successSlot1 = 205

    amount = 10001

    sequence = [0] * 4
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, amountSlot, successSlot0, resultSlot0]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint256', 'address', 'uint8'],
      [READ_TRANSIENT_BALANCE, 0, operator.address, resultSlot1]
    )
    sequence[3] = encode_packed(
      ['uint8', 'address', 'address', 'uint8', 'uint8'],
      [TAKE_TOKEN, address0, operator.address, amountSlot, successSlot1]
    )
    transientSlots = [amountSlot, successSlot0, resultSlot0, successSlot1, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, amount, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(amountSlot) == amount
    assert payer.storageAccess(successSlot0) == 1
    assert payer.storageAccess(resultSlot0) == amount
    assert payer.storageAccess(resultSlot1) == (2 ** 256) - amount
    assert payer.storageAccess(successSlot1) == 1

def test_READ_BALANCE_OF_NATIVE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    resultSlot = 199

    amount = payer.balance()

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'uint8'],
      [READ_BALANCE_OF_NATIVE, payer.address, resultSlot]
    )
    transientSlots = [resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(resultSlot) == amount

    resultSlot = 199

    amount = root.balance()

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'uint8'],
      [READ_BALANCE_OF_NATIVE, root.address, resultSlot]
    )
    transientSlots = [resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(resultSlot) == amount

def test_READ_BALANCE_OF_ERC20(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    successSlot0 = 4
    successSlot1 = 5

    resultSlot0 = 199
    resultSlot1 = 200

    amount0 = token0.balanceOf(payer)
    amount1 = token1.balanceOf(payer)

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'uint8', 'uint8'],
      [READ_BALANCE_OF_ERC20, token0.address, payer.address, successSlot0, resultSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'address', 'uint8', 'uint8'],
      [READ_BALANCE_OF_ERC20, token1.address, payer.address, successSlot1, resultSlot1]
    )
    transientSlots = [successSlot0, successSlot1, resultSlot0, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot0) == 1
    assert payer.storageAccess(successSlot1) == 1

    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

    successSlot0 = 4
    successSlot1 = 5

    resultSlot0 = 199
    resultSlot1 = 200

    amount0 = token0.balanceOf(root)
    amount1 = token1.balanceOf(root)

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'uint8', 'uint8'],
      [READ_BALANCE_OF_ERC20, token0.address, root.address, successSlot0, resultSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'address', 'uint8', 'uint8'],
      [READ_BALANCE_OF_ERC20, token1.address, root.address, successSlot1, resultSlot1]
    )
    transientSlots = [successSlot0, successSlot1, resultSlot0, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot0) == 1
    assert payer.storageAccess(successSlot1) == 1

    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

def test_READ_BALANCE_OF_MULTITOKEN(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    id0 = 1
    id1 = 1

    successSlot0 = 4
    successSlot1 = 5

    resultSlot0 = 199
    resultSlot1 = 200

    amount0 = tokenERC1155.balanceOf(payer, id0)
    amount1 = tokenERC6909.balanceOf(payer, id1)

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8'],
      [READ_BALANCE_OF_MULTITOKEN, tokenERC1155.address, id0, payer.address, successSlot0, resultSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8'],
      [READ_BALANCE_OF_MULTITOKEN, tokenERC6909.address, id1, payer.address, successSlot1, resultSlot1]
    )
    transientSlots = [successSlot0, successSlot1, resultSlot0, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot0) == 1
    assert payer.storageAccess(successSlot1) == 1

    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

    amount0 = tokenERC1155.balanceOf(root, id0)
    amount1 = tokenERC6909.balanceOf(root, id1)

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8'],
      [READ_BALANCE_OF_MULTITOKEN, tokenERC1155.address, id0, root.address, successSlot0, resultSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8'],
      [READ_BALANCE_OF_MULTITOKEN, tokenERC6909.address, id1, root.address, successSlot1, resultSlot1]
    )
    transientSlots = [successSlot0, successSlot1, resultSlot0, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot0) == 1
    assert payer.storageAccess(successSlot1) == 1

    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

def test_READ_ALLOWANCE_ERC20(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    successSlot0 = 4
    successSlot1 = 5

    resultSlot0 = 199
    resultSlot1 = 200

    amount0 = token0.allowance(payer, operator)
    amount1 = token1.allowance(payer, operator)

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_ALLOWANCE_ERC20, token0.address, payer.address, operator.address, successSlot0, resultSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_ALLOWANCE_ERC20, token1.address, payer.address, operator.address, successSlot1, resultSlot1]
    )
    transientSlots = [successSlot0, successSlot1, resultSlot0, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot0) == 1
    assert payer.storageAccess(successSlot1) == 1

    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

    amount0 = token0.allowance(root, owner)
    amount1 = token1.allowance(root, owner)

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_ALLOWANCE_ERC20, token0.address, root.address, owner.address, successSlot0, resultSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_ALLOWANCE_ERC20, token1.address, root.address, owner.address, successSlot1, resultSlot1]
    )
    transientSlots = [successSlot0, successSlot1, resultSlot0, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot0) == 1
    assert payer.storageAccess(successSlot1) == 1

    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

def test_READ_ALLOWANCE_PERMIT2(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    resultSlot0 = 199
    resultSlot1 = 200

    amount0 = 2 ** 160 - 1
    amount1 = 2 ** 160 - 1

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8'],
      [READ_ALLOWANCE_PERMIT2, token0.address, payer.address, operator.address, resultSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8'],
      [READ_ALLOWANCE_PERMIT2, token1.address, payer.address, operator.address, resultSlot1]
    )
    transientSlots = [resultSlot0, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

    amount0 = 2 ** 120 - 1
    amount1 = 2 ** 120 - 1

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8'],
      [READ_ALLOWANCE_PERMIT2, token0.address, root.address, owner.address, resultSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8'],
      [READ_ALLOWANCE_PERMIT2, token1.address, root.address, owner.address, resultSlot1]
    )
    transientSlots = [resultSlot0, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

def test_READ_ALLOWANCE_ERC6909(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    successSlot = 4

    resultSlot = 199

    id = 1

    amount = tokenERC6909.allowance(payer, operator, id)

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'address', 'uint8', 'uint8'],
      [READ_ALLOWANCE_ERC6909, tokenERC6909.address, id, payer.address, operator.address, successSlot, resultSlot]
    )
    transientSlots = [successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == amount

    id = 2

    amount = tokenERC6909.allowance(root, owner, id)

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'address', 'uint8', 'uint8'],
      [READ_ALLOWANCE_ERC6909, tokenERC6909.address, id, root.address, owner.address, successSlot, resultSlot]
    )
    transientSlots = [successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == 2 ** 25

def test_READ_IS_OPERATOR_ERC6909(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    successSlot = 4

    resultSlot = 199

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_IS_OPERATOR_ERC6909, tokenERC6909.address, payer.address, operator.address, successSlot, resultSlot]
    )
    transientSlots = [successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == 1

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_IS_OPERATOR_ERC6909, tokenERC6909.address, root.address, owner.address, successSlot, resultSlot]
    )
    transientSlots = [successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == 1

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_IS_OPERATOR_ERC6909, tokenERC6909.address, owner.address, root.address, successSlot, resultSlot]
    )
    transientSlots = [successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == 0

def test_READ_IS_APPROVED_FOR_ALL_ERC1155(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    successSlot = 4

    resultSlot = 199

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_IS_APPROVED_FOR_ALL_ERC1155, tokenERC1155.address, payer.address, operator.address, successSlot, resultSlot]
    )
    transientSlots = [successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == 1

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_IS_APPROVED_FOR_ALL_ERC1155, tokenERC1155.address, root.address, owner.address, successSlot, resultSlot]
    )
    transientSlots = [successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == 1

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8', 'uint8'],
      [READ_IS_APPROVED_FOR_ALL_ERC1155, tokenERC1155.address, owner.address, root.address, successSlot, resultSlot]
    )
    transientSlots = [successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == 0

def test_READ_DOUBLE_BALANCE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amount0Slot = 4
    amount1Slot = 5
    successSlot = 6

    value0Slot = 14
    value1Slot = 15

    amount0 = 100
    amount1 = 106

    tag0 = toInt(token0.address)
    tag1 = toInt(token1.address)

    sequence = [0] * 7
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount0, amount0Slot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount1, amount1Slot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint256', 'uint256', 'uint8', 'uint8', 'uint8'],
      [MODIFY_DOUBLE_BALANCE, tag0, tag1, amount0Slot, amount1Slot, successSlot]
    )
    sequence[3] = encode_packed(
      ['uint8', 'uint256', 'uint256', 'address', 'uint8', 'uint8'],
      [READ_DOUBLE_BALANCE, tag0, tag1, payer.address, value0Slot, value1Slot]
    )
    sequence[4] = encode_packed(
      ['uint8', 'uint8', 'uint8'],
      [NEG, amount0Slot, amount0Slot]
    )
    sequence[5] = encode_packed(
      ['uint8', 'uint8', 'uint8'],
      [NEG, amount1Slot, amount1Slot]
    )
    sequence[6] = encode_packed(
      ['uint8', 'uint256', 'uint256', 'uint8', 'uint8', 'uint8'],
      [MODIFY_DOUBLE_BALANCE, tag0, tag1, amount0Slot, amount1Slot, successSlot]
    )

    transientSlots = [value0Slot, value1Slot, amount0Slot, amount1Slot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(value0Slot) == amount0
    assert payer.storageAccess(value1Slot) == amount1

def test_WRAP_NATIVE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    valueSlot = 4
    successSlot = 6

    value = 10000

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, value, valueSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint8', 'uint8'],
      [WRAP_NATIVE, valueSlot, successSlot]
    )

    transientSlots = [valueSlot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = payer.balance()

    tx = payer.call(nofeeswap, value, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = payer.balance()

    assert balanceBefore - balanceAfter == value
    assert payer.storageAccess(successSlot) == 1

    ##########

    value = -10000

    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, value, valueSlot]
    )

    transientSlots = [valueSlot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

def test_UNWRAP_NATIVE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    valueSlot = 10
    successSlot = 20

    value = 10000

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, value, valueSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint8', 'uint8'],
      [UNWRAP_NATIVE, valueSlot, successSlot]
    )

    transientSlots = [valueSlot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = payer.balance()

    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = payer.balance()

    assert balanceAfter - balanceBefore == value
    assert payer.storageAccess(successSlot) == 1

    ##########

    value = -10000

    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, value, valueSlot]
    )

    transientSlots = [valueSlot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    with brownie.reverts():
        tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

def test_PERMIT_PERMIT2(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 10
    successSlot = 20
    successSlot0 = 2
    resultSlot0 = 3

    amount = 10000
    expiration = 2 ** 48 - 1
    nonce = 0
    spender = payer.address
    sigDeadline = 2 ** 48 - 1

    hash = sha3.keccak_256(
        (b'\x19\x01') + \
        sha3.keccak_256(
            encode(
                ['bytes32', 'bytes32', 'uint256', 'address'],
                [
                    sha3.keccak_256('EIP712Domain(string name,uint256 chainId,address verifyingContract)'.encode('utf-8')).digest(),
                    sha3.keccak_256('Permit2'.encode('utf-8')).digest(),
                    brownie.chain.id,
                    permit2
                ]
            )
        ).digest() + \
        sha3.keccak_256(
            encode(
                ['bytes32', 'bytes32', 'address', 'uint256'],
                [
                    sha3.keccak_256('PermitSingle(PermitDetails details,address spender,uint256 sigDeadline)PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)'.encode('utf-8')).digest(),
                    sha3.keccak_256(
                        encode(
                            ['bytes32', 'address', 'uint160', 'uint48', 'uint48'],
                            [
                                sha3.keccak_256('PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)'.encode('utf-8')).digest(),
                                weth9,
                                amount,
                                expiration,
                                nonce
                            ]
                        )
                    ).digest(),
                    spender,
                    sigDeadline
                ]
            )
        ).digest()
    )

    signed = web3.eth.account.signHash(hash.hexdigest(), owner.private_key)

    r = brownie.convert.to_bytes(signed.r, type_str='bytes32')
    s = brownie.convert.to_bytes(signed.s, type_str='bytes32')
    v = signed.v

    signature = encode_packed(['bytes32', 'bytes32', 'uint8'], [r, s, v])

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      [
          'uint8',
          'address',
          'uint48',
          'uint8',
          'address',
          'uint48',
          'uint48',
          'address',
          'uint8',
          'uint8',
          'bytes'
      ],
      [
          PERMIT_PERMIT2,
          owner.address,
          nonce,
          amountSlot,
          weth9,
          expiration,
          sigDeadline,
          spender,
          successSlot,
          len(signature),
          signature
      ]
    )
    sequence[2] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8'],
      [READ_ALLOWANCE_PERMIT2, weth9, owner.address, spender, resultSlot0]
    )

    transientSlots = [successSlot, successSlot0, resultSlot0]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot0) == amount

def test_PERMIT_BATCH_PERMIT2(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot0 = 10
    amountSlot1 = 12

    successSlot = 40
    successSlot0 = 33
    resultSlot0 = 34
    successSlot1 = 35
    resultSlot1 = 36

    amount0 = 11000
    amount1 = 42000
    expiration0 = 2 ** 40 - 2
    expiration1 = 2 ** 40 - 5
    nonce0 = 0
    nonce1 = 0
    spender = payer.address
    sigDeadline = 2 ** 48 - 1

    hash = sha3.keccak_256(
        (b'\x19\x01') + \
        sha3.keccak_256(
            encode(
                ['bytes32', 'bytes32', 'uint256', 'address'],
                [
                    sha3.keccak_256('EIP712Domain(string name,uint256 chainId,address verifyingContract)'.encode('utf-8')).digest(),
                    sha3.keccak_256('Permit2'.encode('utf-8')).digest(),
                    brownie.chain.id,
                    permit2
                ]
            )
        ).digest() + \
        sha3.keccak_256(
            encode(
                ['bytes32', 'bytes32', 'address', 'uint256'],
                [
                    sha3.keccak_256('PermitBatch(PermitDetails[] details,address spender,uint256 sigDeadline)PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)'.encode('utf-8')).digest(),
                    sha3.keccak_256(
                        sha3.keccak_256(
                            encode(
                                ['bytes32', 'address', 'uint160', 'uint48', 'uint48'],
                                [
                                    sha3.keccak_256('PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)'.encode('utf-8')).digest(),
                                    token0.address,
                                    amount0,
                                    expiration0,
                                    nonce0
                                ]
                            )
                        ).digest() + \
                        sha3.keccak_256(
                            encode(
                                ['bytes32', 'address', 'uint160', 'uint48', 'uint48'],
                                [
                                    sha3.keccak_256('PermitDetails(address token,uint160 amount,uint48 expiration,uint48 nonce)'.encode('utf-8')).digest(),
                                    token1.address,
                                    amount1,
                                    expiration1,
                                    nonce1
                                ]
                            )
                        ).digest(),
                    ).digest(),
                    spender,
                    sigDeadline
                ]
            )
        ).digest()
    )

    signed = web3.eth.account.signHash(hash.hexdigest(), owner.private_key)

    r = brownie.convert.to_bytes(signed.r, type_str='bytes32')
    s = brownie.convert.to_bytes(signed.s, type_str='bytes32')
    v = signed.v

    signature = encode_packed(['bytes32', 'bytes32', 'uint8'], [r, s, v])

    sequence = [0] * 5
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount0, amountSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount1, amountSlot1]
    )
    sequence[2] = encode_packed(
      [
          'uint8',
          'address',
          'uint48',
          'uint8',
          'address',
          'uint8',
          'uint8',
          'address',
          'uint8',
          'uint40',
          'uint48',
          'address',
          'uint8',
          'uint40',
          'uint48',
          'bytes'
      ],
      [
          PERMIT_BATCH_PERMIT2,
          owner.address,
          sigDeadline,
          len(signature),
          spender,
          successSlot,
          2,
          token0.address,
          amountSlot0,
          expiration0,
          nonce0,
          token1.address,
          amountSlot1,
          expiration1,
          nonce1,
          signature
      ]
    )
    sequence[3] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8'],
      [READ_ALLOWANCE_PERMIT2, token0.address, owner.address, spender, resultSlot0]
    )
    sequence[4] = encode_packed(
      ['uint8', 'address', 'address', 'address', 'uint8'],
      [READ_ALLOWANCE_PERMIT2, token1.address, owner.address, spender, resultSlot1]
    )

    transientSlots = [successSlot, successSlot0, resultSlot0, successSlot1, resultSlot1]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot0) == amount0
    assert payer.storageAccess(resultSlot1) == amount1

def test_TRANSFER_NATIVE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 10
    successSlot = 20

    amount = 1111100

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'uint8', 'uint8'],
      [TRANSFER_NATIVE, owner.address, amountSlot, successSlot]
    )

    transientSlots = [amountSlot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = owner.balance()

    tx = payer.call(nofeeswap, amount, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = owner.balance()

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(successSlot) == 1

def test_TRANSFER_FROM_PAYER_ERC20(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 12
    successSlot = 22
    resultSlot = 25

    amount = 500

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'uint8', 'address', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC20, token0.address, amountSlot, owner.address, successSlot, resultSlot]
    )

    transientSlots = [amountSlot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = token0.balanceOf(owner)

    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = token0.balanceOf(owner)

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(successSlot) == 1

def test_TRANSFER_FROM_PAYER_PERMIT2(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 121
    successSlot = 221

    amount = 5005

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'uint8', 'address', 'uint8'],
      [TRANSFER_FROM_PAYER_PERMIT2, owner.address, amountSlot, token0.address, successSlot]
    )

    transientSlots = [amountSlot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = token0.balanceOf(owner)

    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = token0.balanceOf(owner)

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(successSlot) == 1

def test_TRANSFER_FROM_PAYER_ERC6909(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 100
    successSlot = 101
    resultSlot = 102

    amount = 505
    id = 1

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC6909, tokenERC6909.address, id, owner.address, amountSlot, successSlot, resultSlot]
    )

    transientSlots = [amountSlot, successSlot, resultSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = tokenERC6909.balanceOf(owner, id)

    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = tokenERC6909.balanceOf(owner, id)

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(resultSlot) == 1

def test_SAFE_TRANSFER_FROM_PAYER_ERC1155(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 200
    successSlot = 201

    amount = 515
    id = 1

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8', 'uint24', 'bytes'],
      [SAFE_TRANSFER_FROM_PAYER_ERC1155, tokenERC1155.address, id, owner.address, amountSlot, successSlot, len(b'transferData'), b'transferData']
    )

    transientSlots = [amountSlot, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = tokenERC1155.balanceOf(owner, id)

    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = tokenERC1155.balanceOf(owner, id)

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(successSlot) == 1

def test_CLEAR(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 95
    successSlotSettle = 195
    resultSlotSettle = 200
    successSlot = 205

    amount = 10001

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, amountSlot, successSlotSettle, resultSlotSettle]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint256', 'uint8', 'uint8'],
      [CLEAR, 0, amountSlot, successSlot]
    )

    transientSlots = [amountSlot, successSlotSettle, resultSlotSettle, successSlot]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = nofeeswap.balance()

    tx = payer.call(nofeeswap, amount, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = nofeeswap.balance()

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(amountSlot) == amount
    assert payer.storageAccess(successSlotSettle) == 1
    assert payer.storageAccess(resultSlotSettle) == amount
    assert payer.storageAccess(successSlot) == 1

def test_TAKE_SETTLE_TOKEN_NATIVE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 1
    successSlot = 2

    successSlotSettle = 3
    resultSlotSettle = 4

    amount = 101

    sequence = [0] * 3
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'address', 'address', 'uint8', 'uint8'],
      [TAKE_TOKEN, address0, owner.address, amountSlot, successSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, amountSlot, successSlotSettle, resultSlotSettle]
    )

    transientSlots = [amountSlot, successSlot, successSlotSettle, resultSlotSettle]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = owner.balance()

    tx = payer.call(nofeeswap, amount, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = owner.balance()

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(amountSlot) == amount
    assert payer.storageAccess(successSlotSettle) == 1
    assert payer.storageAccess(resultSlotSettle) == amount
    assert payer.storageAccess(successSlot) == 1

def test_TAKE_SYNC_SETTLE_TOKEN_ERC20(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    valueSlot = 0

    amountSlot = 1
    successSlot = 2

    successSlotSettle = 3
    resultSlotSettle = 4

    successSlotTransfer = 6
    resultSlotTransfer = 7

    amount = 101

    payer.call(token0, 0, address0, [], token0.transfer.encode_input(nofeeswap, amount))

    sequence = [0] * 6
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, 0, valueSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'address', 'address', 'uint8', 'uint8'],
      [TAKE_TOKEN, token0.address, owner.address, amountSlot, successSlot]
    )
    sequence[3] = encode_packed(
      ['uint8', 'address'],
      [SYNC_TOKEN, token0.address]
    )
    sequence[4] = encode_packed(
      ['uint8', 'address', 'uint8', 'address', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC20, token0.address, amountSlot, nofeeswap.address, successSlotTransfer, resultSlotTransfer]
    )
    sequence[5] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, valueSlot, successSlotSettle, resultSlotSettle]
    )

    transientSlots = [amountSlot, successSlot, successSlotSettle, resultSlotSettle]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = token0.balanceOf(owner)

    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = token0.balanceOf(owner)

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(amountSlot) == amount
    assert payer.storageAccess(resultSlotSettle) == amount
    assert payer.storageAccess(successSlotSettle) == 1
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(successSlotTransfer) == 1

def test_TAKE_SYNC_SETTLE_ERC6909(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    valueSlot = 0

    amountSlot = 1
    successSlot = 2

    successSlotSettle = 3
    resultSlotSettle = 4

    successSlotTransfer = 6
    resultSlotTransfer = 7

    amount = 1010
    id = 1

    payer.call(tokenERC6909, 0, address0, [], tokenERC6909.transfer.encode_input(nofeeswap, id, amount))

    sequence = [0] * 6
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, 0, valueSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8'],
      [TAKE_ERC6909, tokenERC6909.address, id, owner.address, amountSlot, successSlot]
    )
    sequence[3] = encode_packed(
      ['uint8', 'address', 'uint256'],
      [SYNC_MULTITOKEN, tokenERC6909.address, id]
    )
    sequence[4] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC6909, tokenERC6909.address, id, nofeeswap.address, amountSlot, successSlotTransfer, resultSlotTransfer]
    )
    sequence[5] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, valueSlot, successSlotSettle, resultSlotSettle]
    )

    transientSlots = [amountSlot, successSlot, successSlotSettle, resultSlotSettle]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    balanceBefore = tokenERC6909.balanceOf(owner, id)

    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = tokenERC6909.balanceOf(owner, id)

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(amountSlot) == amount
    assert payer.storageAccess(resultSlotSettle) == amount
    assert payer.storageAccess(successSlotSettle) == 1
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(successSlotTransfer) == 1

def test_TAKE_SYNC_SETTLE_ERC1155(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    valueSlot = 0

    amountSlot = 1
    successSlot = 2

    successSlotSettle = 3
    resultSlotSettle = 4

    successSlotTransfer = 6
    resultSlotTransfer = 7

    amount = 2020
    id = 1

    payer.call(tokenERC1155, 0, address0, [], tokenERC1155.safeTransferFrom.encode_input(payer, nofeeswap, id, amount, b'transferData'))

    sequence = [0] * 6
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, 0, valueSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8', 'uint24', 'bytes'],
      [TAKE_ERC1155, tokenERC1155.address, id, owner.address, amountSlot, successSlot, len(b'transferData'), b'transferData']
    )
    sequence[3] = encode_packed(
      ['uint8', 'address', 'uint256'],
      [SYNC_MULTITOKEN, tokenERC1155.address, id]
    )
    sequence[4] = encode_packed(
      ['uint8', 'address', 'uint256', 'address', 'uint8', 'uint8', 'uint24', 'bytes'],
      [SAFE_TRANSFER_FROM_PAYER_ERC1155, tokenERC1155.address, id, nofeeswap.address, amountSlot, successSlotTransfer, len(b'transferData'), b'transferData']
    )
    sequence[5] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, valueSlot, successSlotSettle, resultSlotSettle]
    )

    transientSlots = [amountSlot, successSlot, successSlotSettle, resultSlotSettle]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    balanceBefore = tokenERC1155.balanceOf(owner, id)

    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    balanceAfter = tokenERC1155.balanceOf(owner, id)

    assert balanceAfter - balanceBefore == amount
    assert payer.storageAccess(amountSlot) == amount
    assert payer.storageAccess(resultSlotSettle) == amount
    assert payer.storageAccess(successSlotSettle) == 1
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(successSlotTransfer) == 1

def test_MODIFY_SINGLE_BALANCE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot = 4
    successSlot = 6

    successSlotTransfer = 11
    resultSlotTransfer = 15

    valueSlotSettle = 25
    successSlotSettle = 27
    resultSlotSettle = 99

    amount = 797

    tag = toInt(token0.address)

    sequence = [0] * 5
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount, amountSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint256', 'uint8', 'uint8'],
      [MODIFY_SINGLE_BALANCE, tag, amountSlot, successSlot]
    )
    sequence[2] = encode_packed(
      ['uint8', 'address'],
      [SYNC_TOKEN, token0.address]
    )
    sequence[3] = encode_packed(
      ['uint8', 'address', 'uint8', 'address', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC20, token0.address, amountSlot, nofeeswap.address, successSlotTransfer, resultSlotTransfer]
    )
    sequence[4] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, valueSlotSettle, successSlotSettle, resultSlotSettle]
    )

    transientSlots = [amountSlot, successSlot, successSlotTransfer, resultSlotTransfer, valueSlotSettle, successSlotSettle, resultSlotSettle]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(amountSlot) == amount
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(successSlotTransfer) == 1
    assert payer.storageAccess(valueSlotSettle) == 0
    assert payer.storageAccess(successSlotSettle) == 1
    assert payer.storageAccess(resultSlotSettle) == amount
    assert nofeeswap.balanceOf(payer, tag) == amount

def test_MODIFY_DOUBLE_BALANCE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    amountSlot0 = 4
    amountSlot1 = 5
    successSlot = 6

    successSlotTransfer0 = 11
    resultSlotTransfer0 = 15
    successSlotTransfer1 = 16
    resultSlotTransfer1 = 20

    valueSlotSettle0 = 25
    successSlotSettle0 = 27
    resultSlotSettle0 = 99
    valueSlotSettle1 = 125
    successSlotSettle1 = 127
    resultSlotSettle1 = 199

    readAmountSlot0 = 201
    readAmountSlot1 = 202

    amount0 = 7971
    amount1 = 2971

    tag0 = toInt(token0.address)
    tag1 = toInt(token1.address)

    sequence = [0] * 10
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount0, amountSlot0]
    )
    sequence[1] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, amount1, amountSlot1]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint256', 'uint256', 'uint8', 'uint8', 'uint8'],
      [MODIFY_DOUBLE_BALANCE, tag0, tag1, amountSlot0, amountSlot1, successSlot]
    )
    sequence[3] = encode_packed(
      ['uint8', 'address'],
      [SYNC_TOKEN, token0.address]
    )
    sequence[4] = encode_packed(
      ['uint8', 'address', 'uint8', 'address', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC20, token0.address, amountSlot0, nofeeswap.address, successSlotTransfer0, resultSlotTransfer0]
    )
    sequence[5] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, valueSlotSettle0, successSlotSettle0, resultSlotSettle0]
    )
    sequence[6] = encode_packed(
      ['uint8', 'address'],
      [SYNC_TOKEN, token1.address]
    )
    sequence[7] = encode_packed(
      ['uint8', 'address', 'uint8', 'address', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC20, token1.address, amountSlot1, nofeeswap.address, successSlotTransfer1, resultSlotTransfer1]
    )
    sequence[8] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, valueSlotSettle1, successSlotSettle1, resultSlotSettle1]
    )
    sequence[9] = encode_packed(
      ['uint8', 'uint256', 'uint256', 'address', 'uint8', 'uint8'],
      [READ_DOUBLE_BALANCE, tag0, tag1, payer.address, readAmountSlot0, readAmountSlot1]
    )

    transientSlots = [
        amountSlot0,
        amountSlot1,
        successSlot,
        successSlotTransfer0,
        resultSlotTransfer0,
        successSlotTransfer1,
        resultSlotTransfer1,
        valueSlotSettle0,
        successSlotSettle0,
        resultSlotSettle0,
        valueSlotSettle1,
        successSlotSettle1,
        resultSlotSettle1,
        readAmountSlot0,
        readAmountSlot1
    ]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 0, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(amountSlot0) == amount0
    assert payer.storageAccess(amountSlot1) == amount1
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(successSlotTransfer0) == 1
    assert payer.storageAccess(successSlotTransfer1) == 1
    assert payer.storageAccess(valueSlotSettle0) == 0
    assert payer.storageAccess(successSlotSettle0) == 1
    assert payer.storageAccess(resultSlotSettle0) == amount0
    assert payer.storageAccess(valueSlotSettle1) == 0
    assert payer.storageAccess(successSlotSettle1) == 1
    assert payer.storageAccess(resultSlotSettle1) == amount1
    assert payer.storageAccess(readAmountSlot0) == amount0
    assert payer.storageAccess(readAmountSlot1) == amount1

def test_SWAP(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    tag0 = 0
    tag1 = toInt(token1.address)
    hookData = b"HookData"

    logOffset = -5
    unsaltedPoolId = (2 << 188) + (twosComplementInt8(logOffset) << 180) + (0b11111111111111111111 << 160) + toInt(hook.address)
    poolId = getPoolId(owner.address, unsaltedPoolId)
    qSpacing = 20 * 60 * 57643193118714
    kernel = [
      [0, 0],
      [qSpacing, 2 ** 15]
    ]
    curve = [
      (2 ** 63) - (qSpacing // 2),
      (2 ** 63) + qSpacing - (qSpacing // 2),
      (2 ** 63)
    ]
    lower = min(curve[0], curve[1])
    upper = max(curve[0], curve[1])
    tx = nofeeswap.dispatch(
      delegatee.initialize.encode_input(
          unsaltedPoolId,
          tag0,
          tag1,
          0,
          encodeKernelCompact(kernel),
          encodeCurve(curve),
          b""
      ),
      {'from': owner}
    )

    qMin = lower - (1 << 63) + (logOffset * (1 << 59))
    qMax = upper - (1 << 63) + (logOffset * (1 << 59))
    tagShares = keccak(['uint256', 'int256', 'int256'], [poolId, qMin, qMax])
    shares = 1000000

    sharesSlot = 0

    successSlot = 1
    amount0Slot = 2
    amount1Slot = 3

    successSlotSettle0 = 4
    resultSlotSettle0 = 5

    successSlotTransfer1 = 8
    resultSlotTransfer1 = 9

    valueSlotSettle1 = 10
    successSlotSettle1 = 11
    resultSlotSettle1 = 12

    sharesSuccessSlot = 13

    sequence = [0] * 7
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, shares, sharesSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint256', 'uint64', 'uint64', 'uint8', 'uint8', 'uint8', 'uint8', 'uint16', 'bytes'],
      [MODIFY_POSITION, poolId, lower, upper, sharesSlot, successSlot, amount0Slot, amount1Slot, len(hookData), hookData]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, amount0Slot, successSlotSettle0, resultSlotSettle0]
    )
    sequence[3] = encode_packed(
      ['uint8', 'address'],
      [SYNC_TOKEN, token1.address]
    )
    sequence[4] = encode_packed(
      ['uint8', 'address', 'uint8', 'address', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC20, token1.address, amount1Slot, nofeeswap.address, successSlotTransfer1, resultSlotTransfer1]
    )
    sequence[5] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, valueSlotSettle1, successSlotSettle1, resultSlotSettle1]
    )
    sequence[6] = encode_packed(
      ['uint8', 'uint256', 'uint8', 'uint8'],
      [MODIFY_SINGLE_BALANCE, tagShares, sharesSlot, sharesSuccessSlot]
    )

    transientSlots = [
        sharesSlot,
        successSlot,
        amount0Slot,
        amount1Slot,
        successSlotSettle0,
        resultSlotSettle0,
        successSlotTransfer1,
        resultSlotTransfer1,
        valueSlotSettle1,
        successSlotSettle1,
        resultSlotSettle1,
        sharesSuccessSlot
    ]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    amount0Before = payer.balance()
    amount1Before = token1.balanceOf(payer)
    
    tx = payer.call(nofeeswap, 10000000000000, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    amount0After = payer.balance()
    amount1After = token1.balanceOf(payer)

    assert payer.storageAccess(sharesSlot) == shares
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(amount0Slot) == amount0Before - amount0After
    assert payer.storageAccess(amount1Slot) == amount1Before - amount1After
    assert payer.storageAccess(successSlotSettle0) == 1
    assert payer.storageAccess(resultSlotSettle0) == amount0Before - amount0After
    assert payer.storageAccess(successSlotTransfer1) == 1
    assert payer.storageAccess(resultSlotTransfer1) == 1
    assert payer.storageAccess(valueSlotSettle1) == 0
    assert payer.storageAccess(successSlotSettle1) == 1
    assert payer.storageAccess(resultSlotSettle1) == amount1Before - amount1After
    assert payer.storageAccess(sharesSuccessSlot) == 1

    ############

    sequence = [0] * 6
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, shares, sharesSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint256', 'uint8', 'uint8', 'uint8', 'uint8', 'uint16', 'bytes'],
      [DONATE, poolId, sharesSlot, successSlot, amount0Slot, amount1Slot, len(hookData), hookData]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, amount0Slot, successSlotSettle0, resultSlotSettle0]
    )
    sequence[3] = encode_packed(
      ['uint8', 'address'],
      [SYNC_TOKEN, token1.address]
    )
    sequence[4] = encode_packed(
      ['uint8', 'address', 'uint8', 'address', 'uint8', 'uint8'],
      [TRANSFER_FROM_PAYER_ERC20, token1.address, amount1Slot, nofeeswap.address, successSlotTransfer1, resultSlotTransfer1]
    )
    sequence[5] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, valueSlotSettle1, successSlotSettle1, resultSlotSettle1]
    )

    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    amount0Before = payer.balance()
    amount1Before = token1.balanceOf(payer)
    
    tx = payer.call(nofeeswap, 10000000000000, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    amount0After = payer.balance()
    amount1After = token1.balanceOf(payer)

    assert payer.storageAccess(sharesSlot) == shares
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(amount0Slot) == amount0Before - amount0After
    assert payer.storageAccess(amount1Slot) == amount1Before - amount1After
    assert payer.storageAccess(successSlotSettle0) == 1
    assert payer.storageAccess(resultSlotSettle0) == amount0Before - amount0After
    assert payer.storageAccess(successSlotTransfer1) == 1
    assert payer.storageAccess(resultSlotTransfer1) == 1
    assert payer.storageAccess(valueSlotSettle1) == 0
    assert payer.storageAccess(successSlotSettle1) == 1
    assert payer.storageAccess(resultSlotSettle1) == amount1Before - amount1After

    ############

    amountSpecified = - (1 << 120)
    limit = lower - (1 << 63) + (logOffset * (1 << 59))
    zeroForOne = 2

    amountSpecifiedSlot = 15
    crossThresholdSlot = 99

    sequence = [0] * 5
    sequence[0] = encode_packed(
      ['uint8', 'int128', 'uint8'],
      [PUSH16, amountSpecified, amountSpecifiedSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint256', 'uint8', 'uint64', 'uint8', 'uint8', 'uint8', 'uint8', 'uint8', 'uint16', 'bytes'],
      [SWAP, poolId, amountSpecifiedSlot, lower, zeroForOne, crossThresholdSlot, successSlot, amount0Slot, amount1Slot, len(hookData), hookData]
    )
    sequence[2] = encode_packed(
      ['uint8', 'uint8', 'uint8', 'uint8'],
      [SETTLE, amount0Slot, successSlotSettle0, resultSlotSettle0]
    )
    sequence[3] = encode_packed(
      ['uint8', 'uint8', 'uint8'],
      [NEG, amount1Slot, amount1Slot]
    )
    sequence[4] = encode_packed(
      ['uint8', 'address', 'address', 'uint8', 'uint8'],
      [TAKE_TOKEN, token1.address, payer.address, amount1Slot, successSlotSettle1]
    )

    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    amount0Before = payer.balance()
    amount1Before = token1.balanceOf(payer)
    
    tx = payer.call(nofeeswap, 10000000000000, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    amount0After = payer.balance()
    amount1After = token1.balanceOf(payer)

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(amount0Slot) == amount0Before - amount0After
    assert payer.storageAccess(amount1Slot) == amount1After - amount1Before
    assert payer.storageAccess(successSlotSettle0) == 1
    assert payer.storageAccess(successSlotSettle1) == 1

def test_QUOTE_SWAP(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    tag0 = 0
    tag1 = toInt(token1.address)
    hookData = b"HookData"

    logOffset = -5
    unsaltedPoolId = (2 << 188) + (twosComplementInt8(logOffset) << 180) + (0b11111111111111111111 << 160) + toInt(hook.address)
    poolId = getPoolId(owner.address, unsaltedPoolId)
    qSpacing = 20 * 60 * 57643193118714
    kernel = [
      [0, 0],
      [qSpacing, 2 ** 15]
    ]
    curve = [
      (2 ** 63) - (qSpacing // 2),
      (2 ** 63) + qSpacing - (qSpacing // 2),
      (2 ** 63)
    ]
    lower = min(curve[0], curve[1])
    upper = max(curve[0], curve[1])

    ############

    successSlot = 1
    amount0Slot = 2
    amount1Slot = 3

    amountSpecified = - (1 << 120)
    limit = lower - (1 << 63) + (logOffset * (1 << 59))
    zeroForOne = 2

    amountSpecifiedSlot = 15
    crossThresholdSlot = 99

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int128', 'uint8'],
      [PUSH16, amountSpecified, amountSpecifiedSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint256', 'uint8', 'uint64', 'uint8', 'uint8', 'uint8', 'uint8', 'uint8', 'uint16', 'bytes'],
      [QUOTE_SWAP, poolId, amountSpecifiedSlot, lower, zeroForOne, crossThresholdSlot, successSlot, amount0Slot, amount1Slot, len(hookData), hookData]
    )

    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    transientSlots = [successSlot, amount0Slot, amount1Slot]
    
    tx = payer.call(nofeeswap, 10000000000000, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(amount0Slot) == keccakPacked(
        [
            'uint32',
            'uint256',
            'int256',
            'int256',
            'uint256',
            'uint256',
            'uint256',
            'bytes'
        ],
        [
            toInt(nofeeswap.swap.signature),
            poolId,
            amountSpecified,
            limit,
            zeroForOne,
            0xA0,
            len(hookData),
            hookData
        ]
    )
    assert payer.storageAccess(amount1Slot) == (1 << 256) - 1

def test_QUOTE_MODIFY_POSITION(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    tag0 = 0
    tag1 = toInt(token1.address)
    hookData = b"HookData"

    logOffset = -5
    unsaltedPoolId = (2 << 188) + (twosComplementInt8(logOffset) << 180) + (0b11111111111111111111 << 160) + toInt(hook.address)
    poolId = getPoolId(owner.address, unsaltedPoolId)
    qSpacing = 20 * 60 * 57643193118714
    kernel = [
      [0, 0],
      [qSpacing, 2 ** 15]
    ]
    curve = [
      (2 ** 63) - (qSpacing // 2),
      (2 ** 63) + qSpacing - (qSpacing // 2),
      (2 ** 63)
    ]
    lower = min(curve[0], curve[1])
    upper = max(curve[0], curve[1])

    qMin = lower - (1 << 63) + (logOffset * (1 << 59))
    qMax = upper - (1 << 63) + (logOffset * (1 << 59))
    tagShares = keccak(['uint256', 'int256', 'int256'], [poolId, qMin, qMax])
    shares = 1000000

    sharesSlot = 0

    successSlot = 1
    amount0Slot = 2
    amount1Slot = 3

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, shares, sharesSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint256', 'uint64', 'uint64', 'uint8', 'uint8', 'uint8', 'uint8', 'uint16', 'bytes'],
      [QUOTE_MODIFY_POSITION, poolId, lower, upper, sharesSlot, successSlot, amount0Slot, amount1Slot, len(hookData), hookData]
    )

    transientSlots = [
        sharesSlot,
        successSlot,
        amount0Slot,
        amount1Slot
    ]
    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)
    
    tx = payer.call(nofeeswap, 10000000000000, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(sharesSlot) == shares
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(amount0Slot) == keccakPacked(
        [
            'uint32',
            'uint256',
            'int256',
            'int256',
            'int256',
            'uint256',
            'uint256',
            'bytes'
        ],
        [
            toInt(delegatee.modifyPosition.signature),
            poolId,
            qMin,
            qMax,
            shares,
            0xA0,
            len(hookData),
            hookData
        ]
    )
    assert payer.storageAccess(amount1Slot) == (1 << 256) - 1

def test_QUOTE_DONATE(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    tag0 = 0
    tag1 = toInt(token1.address)
    hookData = b"HookData"

    logOffset = -5
    unsaltedPoolId = (2 << 188) + (twosComplementInt8(logOffset) << 180) + (0b11111111111111111111 << 160) + toInt(hook.address)
    poolId = getPoolId(owner.address, unsaltedPoolId)
    qSpacing = 20 * 60 * 57643193118714
    kernel = [
      [0, 0],
      [qSpacing, 2 ** 15]
    ]
    curve = [
      (2 ** 63) - (qSpacing // 2),
      (2 ** 63) + qSpacing - (qSpacing // 2),
      (2 ** 63)
    ]
    lower = min(curve[0], curve[1])
    upper = max(curve[0], curve[1])

    qMin = lower - (1 << 63) + (logOffset * (1 << 59))
    qMax = upper - (1 << 63) + (logOffset * (1 << 59))
    tagShares = keccak(['uint256', 'int256', 'int256'], [poolId, qMin, qMax])
    shares = 1000000

    sharesSlot = 0
    successSlot = 1
    amount0Slot = 2
    amount1Slot = 3

    transientSlots = [
        sharesSlot,
        successSlot,
        amount0Slot,
        amount1Slot
    ]

    ############

    sequence = [0] * 2
    sequence[0] = encode_packed(
      ['uint8', 'int256', 'uint8'],
      [PUSH32, shares, sharesSlot]
    )
    sequence[1] = encode_packed(
      ['uint8', 'uint256', 'uint8', 'uint8', 'uint8', 'uint8', 'uint16', 'bytes'],
      [QUOTE_DONATE, poolId, sharesSlot, successSlot, amount0Slot, amount1Slot, len(hookData), hookData]
    )

    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    tx = payer.call(nofeeswap, 10000000000000, operator, transientSlots, nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(sharesSlot) == shares
    assert payer.storageAccess(successSlot) == 1
    assert payer.storageAccess(amount0Slot) == keccakPacked(
        [
            'uint32',
            'uint256',
            'uint256',
            'uint256',
            'uint256',
            'bytes'
        ],
        [
            toInt(delegatee.donate.signature),
            poolId,
            shares,
            0x60,
            len(hookData),
            hookData
        ]
    )
    assert payer.storageAccess(amount1Slot) == (1 << 256) - 1

def test_QUOTE_TRANSIENT_ACCESS(deployment, request, worker_id):
    logTest(request, worker_id)
    
    root, owner, nofeeswap, delegatee, operator, hook, payer, token0, token1, tokenERC1155, tokenERC6909, permit2, weth9, deadline = deployment

    resultSlot = 100

    ############

    sequence = [0] * 1
    sequence[0] = encode_packed(
      ['uint8', 'uint256', 'uint8'],
      [QUOTER_TRANSIENT_ACCESS, 55, resultSlot]
    )

    data = encode_packed(['uint32'] + ['bytes'] * len(sequence), [deadline] + sequence)

    tx = payer.call(nofeeswap, 10000000000000, operator, [resultSlot], nofeeswap.unlock.encode_input(operator, data))

    assert payer.storageAccess(resultSlot) == keccakPacked(['uint256'], [55])